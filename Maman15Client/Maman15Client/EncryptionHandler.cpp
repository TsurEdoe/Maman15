#include "EncryptionHandler.h"

/*
    C'tor
*/
EncryptionHandler::EncryptionHandler(RSAWrapper* rsaWrapper, ClientSocketHandler* clientSocketHandler) :
    _rsaWrapper(rsaWrapper), _clientSocketHandler(clientSocketHandler) , _aesWrapper(NULL) { }

/*
    Sends the client generated public RSA key to the server
*/
bool EncryptionHandler::sendPublicKeyToServer(uint8_t* clientUUID, string userName)
{
    uint8_t buffer[PACKET_SIZE];
    memset(buffer, 0, PACKET_SIZE);

    string publicKey = this->_rsaWrapper->getPublicKey();

    EncryptionHandler::padStringWithZeroes(userName, USER_NAME_SIZE);
    string requestPayload = userName + publicKey;
    
    ClientRequest sendPublicKeyRequest(clientUUID, ClientRequest::CLIENT_PUBLIC_KEY, requestPayload.size(), (uint8_t*)(requestPayload).c_str());
    sendPublicKeyRequest.serializeIntoBuffer(buffer);

    return _clientSocketHandler->send(buffer, sendPublicKeyRequest.sizeWithPayload());
}

/*
    Receives the shared AES key generated by the server and decrypts it.
    Initializes the AES Wrapper with the received decrypted key.
*/
bool EncryptionHandler::receiveSharedSecret()
{
    uint8_t buffer[PACKET_SIZE];
    memset(buffer, 0, PACKET_SIZE);

    cout << "EncryptionHandler - Receiving shared key from server" << endl;

    if (!_clientSocketHandler->receive(buffer, sizeof(ServerResponse::ServerResponseHeader) + sizeof(uint32_t) + UUID_LENGTH + ENCRYPTED_SHARED_KEY_LENGTH))
    {
        cout << "ERROR: EncryptionHandler - Failed to receive shared key from server!" << endl;
        return NULL;
    }

    ServerResponse sharedKeyResponse(buffer, sizeof(ServerResponse::ServerResponseHeader) + sizeof(uint32_t) + UUID_LENGTH + ENCRYPTED_SHARED_KEY_LENGTH);

    if (sharedKeyResponse.header._code == ServerResponse::CLIENT_AES_KEY)
    {
        unsigned char* encryptedSharedKey = (unsigned char*)(sharedKeyResponse.payload.payload + UUID_LENGTH);
        
        try
        {
            string decrypteSharedKey = _rsaWrapper->decrypt((char*)encryptedSharedKey, ENCRYPTED_SHARED_KEY_LENGTH);
            
            _aesWrapper = new AESWrapper((const unsigned char*)decrypteSharedKey.c_str(), decrypteSharedKey.size());
        }
        catch (exception e)
        {
            cout << "ERROR - EncryptionHandler: Failed decrypting received shared key " << e.what() << endl;
            return false;
        }
        cout << "EncryptionHandler - Initialized encryption handler successfully" << endl;
        
        return true;
    }

    cout << "ERROR: EncryptionHandler - Failed initizlizing encryption handler, bad response " << sharedKeyResponse.header._code << " type received from server" << endl;

    return false;
}

/*
    Initializes the Handler by sending the public key to the server
*/
bool EncryptionHandler::initializeHandler(uint8_t* clientUUID, string userName)
{
    return sendPublicKeyToServer(clientUUID, userName) && receiveSharedSecret();
}

/*
    Encrypts a given file and returns the encrypted data
*/
string EncryptionHandler::encryptedFileData(uint8_t* dataToEncrypt, uint32_t dataToEncryptLength)
{
    return this->_aesWrapper->encrypt((char*)dataToEncrypt, dataToEncryptLength);
}

void EncryptionHandler::padStringWithZeroes(string& strToPad, uint32_t wantedSize)
{
    if (strToPad.size() < wantedSize)
    {
        strToPad.insert(strToPad.size(), wantedSize - strToPad.size(), 0);
    }
}