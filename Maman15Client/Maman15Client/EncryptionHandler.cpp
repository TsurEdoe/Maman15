#include "EncryptionHandler.h"

/*
    C'tor
*/
EncryptionHandler::EncryptionHandler(RSAWrapper* rsaWrapper, ClientSocketHandler* clientSocketHandler) :
    _rsaWrapper(rsaWrapper), _clientSocketHandler(clientSocketHandler) , _aesWrapper(NULL) { }

/*
    Sends the client generated public RSA key to the server
*/
bool EncryptionHandler::sendPublicKeyToServer(uint8_t* clientUUID, string userName)
{
    uint8_t buffer[PACKET_SIZE];
    memset(buffer, 0, PACKET_SIZE);

    string publicKey = this->_rsaWrapper->getPublicKey();
    
    ClientRequest sendPublicKeyRequest(clientUUID, ClientRequest::CLIENT_PUBLIC_KEY, userName.size(), (uint8_t*)userName.c_str());
    sendPublicKeyRequest.serializeIntoBuffer(buffer);

    return _clientSocketHandler->send(buffer);
}

/*
    Receives the shared AES key generated by the server and decrypts it.
    Initializes the AES Wrapper with the received decrypted key.
*/
bool EncryptionHandler::receiveSharedSecret()
{
    uint8_t buffer[PACKET_SIZE];
    memset(buffer, 0, PACKET_SIZE);

    if (!_clientSocketHandler->receive(buffer))
    {
        cout << "ERROR: RegistrationHandler - Failed to receive registration response from server!" << endl;
        return NULL;
    }

    ServerResponse sharedKeyResponse(buffer, sizeof(ServerResponse::ServerResponseHeader) + UUID_LENGTH);

    if (sharedKeyResponse.header._code == ServerResponse::CLIENT_AES_KEY)
    {
        string decrypteSharedKey = _rsaWrapper->decrypt((const char*)sharedKeyResponse.payload.payload, sharedKeyResponse.payload.size);
        _aesWrapper = new AESWrapper((const unsigned char*)decrypteSharedKey.c_str(), decrypteSharedKey.size());

        cout << "Initialized encryption handler successfully" << endl;
        
        return true;
    }

    cout << "Failed initizlizing encryption handler, bad response " << sharedKeyResponse.header._code << " type received from server" << endl;

    return false;
}

/*
    Initializes the Handler by sending the public key to the server
*/
bool EncryptionHandler::initializeHandler(uint8_t* clientUUID, string userName)
{
    return sendPublicKeyToServer(clientUUID, userName) && receiveSharedSecret();
}

/*
    Sends anencrypted data message to the server with the wanted request code
*/
bool EncryptionHandler::sendEncryptedFileData(uint8_t* plainDataToSend, uint32_t sizeOfDataToSend, 
    uint8_t* clientUUID, ClientRequest::RequestCode requestCode)
{
    uint8_t buffer[PACKET_SIZE];
    memset(buffer, 0, PACKET_SIZE);

    string encryptedData = this->_aesWrapper->encrypt((char*)plainDataToSend, sizeOfDataToSend);
    
    ClientRequest sendEncryptedDataToServer;
    
    memcpy(sendEncryptedDataToServer._clientId, clientUUID, UUID_LENGTH);
    sendEncryptedDataToServer._code = requestCode;
    memcpy(sendEncryptedDataToServer._payload.payload, encryptedData.c_str(), encryptedData.size());

    sendEncryptedDataToServer.serializeIntoBuffer(buffer);

    return _clientSocketHandler->send(buffer);
}